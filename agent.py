import numpy as np
import strategy

class Agent:
    """
    Class representing the intelligent Agent using a Minimax strategy. Initializes
    its own strategy with the board state of its first turn, and decides the
    next move based on the tree generated by the strategy. Also checks user moves
    to decide the best next move.
    """

    def __init__(self, board, limh):
        self.strategy = strategy.Strategy(board, limh)

    def move(self, current_board):
        """
        Gets the next best move from the strategy tree, updates the tree
        and returns (to the game) the entire board containing its next
        move.
        """

        transform = self.strategy.root.is_equivalent_by(current_board) # Equivalence transformation
        best = self.strategy.root.best_child()
        self.strategy.next_step(best)

        next_board = best.randt()

        if transform == 'id':
            next_board = np.copy(next_board).tolist()
        if transform == 'ta':
            next_board = np.flip(np.swapaxes(np.flip(next_board, 1), 0, 1), 1).tolist()
        if transform == 'td':
            next_board = np.swapaxes(next_board,0,1).tolist()
        if transform == 'mh':
            next_board = np.flip(next_board, 0).tolist()
        if transform == 'mv':
            next_board = np.flip(next_board, 1).tolist()
        if transform == 'r90':
            next_board = np.rot90(next_board,k=1).tolist()
        if transform == 'r180':
            next_board = np.rot90(next_board,k=2).tolist()
        if transform == 'r270':
            next_board = np.rot90(next_board,k=3).tolist()
        return next_board
    
    def check_usermov(self, current_board):
        """
        Updates its strategy tree with the user move.
        """
        for child in self.strategy.root.children:
            if child.is_equivalent_by(current_board) != 'none':
                self.strategy.next_step(child)
                break
